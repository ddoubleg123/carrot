generator client {
  provider = "prisma-client-js"
}

// ===== Append-only Training Models =====
model TrainingPlan {
  id          String           @id @default(cuid())
  agentId     String
  topics      String // JSON stringified string[]
  options     String // JSON stringified TrainingPlanOptions
  status      String
  totals      String // JSON stringified totals
  topicPages  String // JSON stringified Record<string, number>
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  tasks       TrainingTask[]
  discoveries DiscoveryEntry[]
}

model TrainingTask {
  id           String       @id @default(cuid())
  planId       String
  agentId      String
  topic        String
  page         Int
  status       String
  itemsFed     Int          @default(0)
  itemsDropped Int          @default(0)
  attempts     Int          @default(0)
  lastError    String?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  plan         TrainingPlan @relation(fields: [planId], references: [id])
}

model DiscoveryEntry {
  id         String       @id @default(cuid())
  planId     String
  topic      String
  page       Int
  url        String?
  title      String?
  sourceType String?
  status     String
  ts         DateTime     @default(now())
  plan       TrainingPlan @relation(fields: [planId], references: [id])
}

// Playback/user preferences synchronized across devices
model UserPref {
  userId          String   @id
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  captionsDefault Boolean  @default(true)
  reducedMotion   Boolean  @default(false)
  autoplay        Boolean  @default(true)
  updatedAt       DateTime @updatedAt
  createdAt       DateTime @default(now())
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl is optional - only needed for migrations in some environments
  // directUrl = env("DIRECT_DATABASE_URL")
}

/// Visual style used by audio poster visualizer
enum VisualStyle {
  liquid
  radial
  arc
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id                String             @id @default(cuid())
  name              String?
  email             String?            @unique
  emailVerified     DateTime?          @map("email_verified")
  image             String?
  profilePhoto      String?
  profilePhotoPath  String?            @map("profile_photo_path")
  isOnboarded       Boolean            @default(false)
  username          String?            @unique
  firstName         String?
  lastName          String?
  phone             String?
  country           String?
  postalCode        String?
  /// Flexible, future-proof metadata
  metadata          Json?
  /// User interests (freeform, sanitized)
  interests         String?
  /// Terms of Service acceptance timestamp
  tosAcceptedAt     DateTime?          @map("tos_accepted_at")
  /// Privacy Policy acceptance timestamp  
  privacyAcceptedAt DateTime?          @map("privacy_accepted_at")
  /// Version of TOS accepted (for tracking policy changes)
  tosVersion        String?            @map("tos_version")
  /// Version of Privacy Policy accepted (for tracking policy changes)
  privacyVersion    String?            @map("privacy_version")
  onboardingAnswers OnboardingAnswer[]
  accounts          Account[]
  posts             Post[]
  sessions          Session[]
  userVideos        UserVideo[]
  /// Server-backed playback preferences (one-to-one)
  userPref          UserPref?
  // Media Library relations
  mediaAssets       MediaAsset[]
  mediaLabels       MediaLabel[]
  mediaCollections  MediaCollection[]
  // Comments relation
  comments          Comment[]
  // Engagement relations
  postLikes         PostLike[]
  postSaves         PostSave[]
  // Patch system relations
  createdPatches    Patch[]            @relation("PatchCreator")
  addedSources      Source[]           @relation("SourceAdder")
  patchPosts        PatchPost[]        @relation("PatchPostAuthor")
  patchMemberships  PatchMember[]      @relation("PatchMembers")
  // New patch system relations
  patchThemes       UserPatchTheme[]
  patchFollowers    Follower[]
  botSubscriptions  BotSubscription[]
}

model Post {
  id                  String       @id @default(cuid())
  content             String
  userId              String
  /// Stable seed for poster visualizer (palette, motion)
  visualSeed          String?
  /// Persisted style for poster visualizer. If null, UI will derive from seed.
  visualStyle         VisualStyle?
  gradientDirection   String?
  gradientFromColor   String?
  gradientViaColor    String?
  gradientToColor     String?
  imageUrls           String?
  gifUrl              String?
  audioUrl            String?
  audioTranscription  String?
  transcriptionStatus String?
  emoji               String?
  carrotText          String?
  stickText           String?
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt
  /// Edit metadata
  editedAt            DateTime?
  editCount           Int          @default(0)
  lastEditedBy        String?
  thumbnailUrl        String?
  videoUrl            String?
  /// Durable Firebase Storage location for path-mode playback (avoids signed URL expiry)
  videoBucket         String?      @db.VarChar(191)
  videoPath           String?
  /// Cloudflare Stream fields
  cfUid               String?      @map("cf_uid")
  cfStatus            String?      @map("cf_status")
  cfDurationSec       Float?       @map("cf_duration_sec")
  cfWidth             Int?         @map("cf_width")
  cfHeight            Int?         @map("cf_height")
  cfPlaybackUrlHls    String?      @map("cf_playback_url_hls")
  captionVttUrl       String?      @map("caption_vtt_url")
  User                User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  // Comments relation
  comments            Comment[]
  // Engagement
  likes               PostLike[]
  saves               PostSave[]

  @@index([videoBucket, videoPath])
  @@map("posts")
}

model OnboardingQuestion {
  id      String             @id @default(cuid())
  slug    String             @unique
  label   String
  type    String
  options Json?
  answers OnboardingAnswer[]
}

model OnboardingAnswer {
  id         String             @id @default(cuid())
  userId     String
  questionId String
  answer     Json
  user       User               @relation(fields: [userId], references: [id])
  question   OnboardingQuestion @relation(fields: [questionId], references: [id])

  @@unique([userId, questionId], name: "userId_questionId")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model IngestJob {
  id           String   @id
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  userId       String?  @map("user_id")
  postId       String?  @map("post_id")
  sourceUrl    String   @map("source_url")
  sourceType   String   @map("source_type")
  status       String
  progress     Int?
  error        String?
  mediaUrl     String?  @map("media_url")
  videoUrl     String?  @map("video_url")
  thumbnailUrl String?  @map("thumbnail_url")
  cfUid        String?  @map("cf_uid")
  cfStatus     String?  @map("cf_status")
  durationSec  Float?   @map("duration_sec")
  width        Int?
  height       Int?
  title        String?
  channel      String?

  @@map("ingest_jobs")
}

// Video deduplication system tables
model SourceAsset {
  id                  String    @id @default(cuid())
  platform            String // 'youtube', 'x', 'reddit', 'other'
  sourceUrlRaw        String    @map("source_url_raw")
  sourceUrlNormalized String    @unique @map("source_url_normalized")
  externalId          String?   @map("external_id")
  storageUri          String?   @map("storage_uri")
  contentHash         String?   @map("content_hash")
  durationSec         Int?      @map("duration_sec")
  width               Int?
  height              Int?
  fps                 Float?
  title               String?
  authorHandle        String?   @map("author_handle")
  publishedAt         DateTime? @map("published_at")
  status              String    @default("pending")
  version             Int       @default(1)
  refcount            Int       @default(0)
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Opposite relation fields
  userVideos    UserVideo[]
  videoVariants VideoVariant[]
  ingestionJobs IngestionJob[]

  @@unique([platform, externalId], name: "platform_external_id")
  @@index([contentHash])
  @@map("source_assets")
}

model UserVideo {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  assetId       String   @map("asset_id")
  role          String   @default("original_ref") @map("role") // original_ref
  status        String   @default("draft") // draft | published | archived
  titleOverride String?  @map("title_override")
  notes         String?
  posterUri     String?  @map("poster_uri")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  asset    SourceAsset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  variants VideoVariant[]

  @@unique([userId, assetId], name: "user_asset")
  @@map("user_videos")
}

model VideoVariant {
  id                 String   @id @default(cuid())
  userVideoId        String   @map("user_video_id")
  derivedFromAssetId String   @map("derived_from_asset_id")
  variantKind        String   @default("edit") @map("variant_kind") // edit | captioned | clipped
  storageUri         String   @map("storage_uri")
  contentHash        String?  @map("content_hash")
  durationSec        Int?     @map("duration_sec")
  width              Int?
  height             Int?
  fps                Float?
  editManifest       Json     @map("edit_manifest") // timeline cuts, overlays, subtitles, filters
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  userVideo        UserVideo   @relation(fields: [userVideoId], references: [id], onDelete: Cascade)
  derivedFromAsset SourceAsset @relation(fields: [derivedFromAssetId], references: [id])

  @@index([derivedFromAssetId])
  @@map("video_variants")
}

model IngestionJob {
  id                  String   @id @default(cuid())
  userId              String   @map("user_id")
  sourceUrlRaw        String   @map("source_url_raw")
  sourceUrlNormalized String   @map("source_url_normalized")
  platform            String
  externalId          String?  @map("external_id")
  assetId             String?  @map("asset_id")
  idempotencyKey      String   @unique @map("idempotency_key") // sha256(normalized_url)
  state               String   @default("queued") // queued | running | succeeded | failed
  error               String?
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  asset SourceAsset? @relation(fields: [assetId], references: [id])

  @@map("ingestion_jobs")
}

/// MEDIA LIBRARY MODELS

model MediaAsset {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  type          String
  url           String
  storagePath   String?  @map("storage_path")
  thumbUrl      String?  @map("thumb_url")
  thumbPath     String?  @map("thumb_path")
  title         String?
  hidden        Boolean  @default(false)
  source        String?
  durationSec   Float?   @map("duration_sec")
  width         Int?
  height        Int?
  inUseCount    Int      @default(0) @map("in_use_count")
  cfUid         String?  @map("cf_uid")
  cfStatus      String?  @map("cf_status")
  captionVttUrl String?  @map("caption_vtt_url")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user        User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  labels      MediaAssetLabel[]
  collections MediaAssetCollection[]

  @@unique([userId, url], name: "user_url_unique")
  @@index([userId])
  @@map("media_assets")
}

model MediaLabel {
  id     String @id @default(cuid())
  userId String @map("user_id")
  name   String

  user   User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  assets MediaAssetLabel[]

  @@unique([userId, name], name: "user_label_unique")
  @@index([userId])
  @@map("media_labels")
}

model MediaAssetLabel {
  id      String     @id @default(cuid())
  assetId String     @map("asset_id")
  labelId String     @map("label_id")
  asset   MediaAsset @relation(fields: [assetId], references: [id], onDelete: Cascade)
  label   MediaLabel @relation(fields: [labelId], references: [id], onDelete: Cascade)

  @@unique([assetId, labelId], name: "asset_label_unique")
  @@index([labelId])
  @@map("media_asset_labels")
}

model MediaCollection {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  name      String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  assets MediaAssetCollection[]

  @@unique([userId, name], name: "user_collection_unique")
  @@index([userId])
  @@map("media_collections")
}

model MediaAssetCollection {
  id           String          @id @default(cuid())
  assetId      String          @map("asset_id")
  collectionId String          @map("collection_id")
  asset        MediaAsset      @relation(fields: [assetId], references: [id], onDelete: Cascade)
  collection   MediaCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([assetId, collectionId], name: "asset_collection_unique")
  @@index([collectionId])
  @@map("media_asset_collections")
}

/// COMMENTS
model Comment {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  text      String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([userId])
  @@map("comments")
}

/// POST ENGAGEMENT
model PostLike {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId], name: "post_user_like_unique")
  @@index([postId])
  @@index([userId])
  @@map("post_likes")
}

model PostSave {
  id        String   @id @default(cuid())
  postId    String   @map("post_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId], name: "post_user_save_unique")
  @@index([postId])
  @@index([userId])
  @@map("post_saves")
}

// Patch system models for Reddit/Wikipedia-style group pages
model Patch {
  id               String   @id @default(cuid())
  handle           String   @unique
  title            String
  tagline          String? // Short one-liner for header
  description      String
  rules            String?
  tags             String[]
  theme            String? // 'light' | 'warm' | 'stone' - background variant
  createdBy        String   @map("created_by")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")
  entity           Json?    @map("entity")
  guide            Json?
  sourcesWhitelist Json?    @map("sources_whitelist")

  // Relations
  creator             User                  @relation("PatchCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  facts               Fact[]
  events              Event[]
  sources             Source[]
  posts               PatchPost[]
  members             PatchMember[]
  // New relations
  userThemes          UserPatchTheme[]
  followers           Follower[]
  botSubscriptions    BotSubscription[]
  discoveredContent   DiscoveredContent[]
  discoveryRuns       DiscoveryRun[]
  discoveryAudits     DiscoveryAudit[]
  seenUrls            SeenUrl[]
  wikipediaMonitoring WikipediaMonitoring[]

  @@index([handle])
  @@index([createdBy])
  @@map("patches")
}

model Fact {
  id       String  @id @default(cuid())
  patchId  String  @map("patch_id")
  label    String
  value    String
  sourceId String? @map("source_id")

  patch  Patch   @relation(fields: [patchId], references: [id], onDelete: Cascade)
  source Source? @relation(fields: [sourceId], references: [id], onDelete: SetNull)

  @@index([patchId])
  @@map("facts")
}

model Event {
  id        String    @id @default(cuid())
  patchId   String    @map("patch_id")
  title     String
  dateStart DateTime  @map("date_start")
  dateEnd   DateTime? @map("date_end")
  summary   String
  media     Json? // { type: 'image' | 'video', url: string, alt?: string }
  tags      String[]
  sourceIds String[]  @map("source_ids")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  patch   Patch    @relation(fields: [patchId], references: [id], onDelete: Cascade)
  sources Source[] @relation("EventSources")

  @@index([patchId])
  @@index([dateStart])
  @@map("events")
}

model Source {
  id          String    @id @default(cuid())
  patchId     String    @map("patch_id")
  title       String
  url         String
  author      String?
  publisher   String?
  publishedAt DateTime? @map("published_at")
  addedBy     String    @map("added_by")
  citeMeta    Json?     @map("cite_meta") // { title, url, author?, publisher?, publishedAt? }
  createdAt   DateTime  @default(now()) @map("created_at")

  patch  Patch   @relation(fields: [patchId], references: [id], onDelete: Cascade)
  adder  User    @relation("SourceAdder", fields: [addedBy], references: [id], onDelete: Cascade)
  facts  Fact[]
  events Event[] @relation("EventSources")

  @@index([patchId])
  @@index([addedBy])
  @@map("sources")
}

model PatchPost {
  id        String   @id @default(cuid())
  patchId   String   @map("patch_id")
  authorId  String   @map("author_id")
  type      PostType
  title     String?
  body      String?
  media     Json? // { type: 'image' | 'video', url: string, alt?: string }
  url       String?
  tags      String[]
  metrics   Json // { likes: number, comments: number, reposts: number, views: number }
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  patch  Patch @relation(fields: [patchId], references: [id], onDelete: Cascade)
  author User  @relation("PatchPostAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([patchId])
  @@index([authorId])
  @@index([createdAt])
  @@map("patch_posts")
}

model PatchMember {
  id       String   @id @default(cuid())
  patchId  String   @map("patch_id")
  userId   String   @map("user_id")
  role     String   @default("member") // member, moderator, admin
  joinedAt DateTime @default(now()) @map("joined_at")

  patch Patch @relation(fields: [patchId], references: [id], onDelete: Cascade)
  user  User  @relation("PatchMembers", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([patchId, userId], name: "patch_user_member_unique")
  @@index([patchId])
  @@index([userId])
  @@map("patch_members")
}

enum PostType {
  CARROT
  TEXT
  LINK
  IMAGE
  VIDEO
}

// AI Agent System Models
model Agent {
  id                String   @id @default(cuid())
  name              String
  persona           String // Detailed personality and expertise description
  domainExpertise   String[] // Taxonomy tags for expertise areas
  associatedPatches String[] // Group pages or topic areas this agent covers
  vectorDbRef       String? // Reference to vector DB collection
  knowledgeProfile  Json? // Current belief map or knowledge profile
  feedSubscriptions Json? // RSS feeds, webhooks, etc.
  metadata          Json     @default("{}") // Council membership, visibility, training enabled, etc.
  isActive          Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  memories      AgentMemory[]
  feedEvents    AgentFeedEvent[]
  conversations AgentConversation[]

  @@map("agents")
}

model AgentMemory {
  id           String   @id @default(cuid())
  agentId      String   @map("agent_id")
  content      String // The actual memory content
  embedding    Float[] // Vector embedding of the content
  sourceType   String // "url", "file", "post", "manual", etc.
  sourceUrl    String? // Original source URL
  sourceTitle  String? // Title of the source
  sourceAuthor String? // Author of the source
  tags         String[] // Topic tags, sentiment, bias labels, etc.
  confidence   Float    @default(1.0) // Confidence score for this memory
  threadId     String? // Associated Carrot group page thread ID
  topicId      String? // Associated topic ID
  fedBy        String? // User ID who fed this memory
  createdAt    DateTime @default(now())

  agent             Agent              @relation(fields: [agentId], references: [id], onDelete: Cascade)
  wikipediaCitation WikipediaCitation?

  @@map("agent_memories")
}

model AgentFeedEvent {
  id          String   @id @default(cuid())
  agentId     String   @map("agent_id")
  eventType   String // "feed", "forget", "reweight", etc.
  content     String // Description of what was fed
  sourceUrl   String? // Source URL if applicable
  sourceTitle String? // Source title if applicable
  memoryIds   String[] // IDs of memories created/affected
  fedBy       String? // User ID who performed the action
  metadata    Json     @default("{}") // Additional event metadata
  createdAt   DateTime @default(now())

  agent Agent @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@map("agent_feed_events")
}

model AgentConversation {
  id        String   @id @default(cuid())
  agentId   String   @map("agent_id")
  threadId  String? // Carrot thread ID if connected
  query     String // The user's query
  response  String // Agent's response
  context   Json? // Additional context for the conversation
  memoryIds String[] // Memory IDs that influenced this response
  createdAt DateTime @default(now())

  agent Agent @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@map("agent_conversations")
}

// New Patch System Models
model UserPatchTheme {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  patchId   String   @map("patch_id")
  mode      String // 'preset' | 'image'
  preset    String? // 'light' | 'warm' | 'stone' | 'civic' | 'ink'
  imageUrl  String?  @map("image_url")
  updatedAt DateTime @updatedAt @map("updated_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  patch Patch @relation(fields: [patchId], references: [id], onDelete: Cascade)

  @@unique([userId, patchId], name: "user_patch_theme_unique")
  @@index([userId])
  @@index([patchId])
  @@map("user_patch_themes")
}

model Follower {
  id        String   @id @default(cuid())
  patchId   String   @map("patch_id")
  userId    String   @map("user_id")
  createdAt DateTime @default(now()) @map("created_at")

  patch Patch @relation(fields: [patchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([patchId, userId], name: "patch_user_follower_unique")
  @@index([patchId])
  @@index([userId])
  @@map("followers")
}

model BotSubscription {
  id          String   @id @default(cuid())
  patchId     String   @map("patch_id")
  botId       String   @map("bot_id")
  ownerUserId String   @map("owner_user_id")
  createdAt   DateTime @default(now()) @map("created_at")

  patch Patch @relation(fields: [patchId], references: [id], onDelete: Cascade)
  owner User  @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)

  @@unique([patchId, botId], name: "patch_bot_subscription_unique")
  @@index([patchId])
  @@index([ownerUserId])
  @@map("bot_subscriptions")
}

// AI-Discovered Content for Patches
model DiscoveredContent {
  id              String    @id @default(cuid())
  patchId         String    @map("patch_id")
  canonicalUrl    String    @map("canonical_url")
  title           String
  sourceUrl       String    @map("source_url")
  sourceDomain    String?   @map("source_domain") @db.VarChar(255)
  domain          String?   @db.Text
  type            String    @default("article") // "article" | "video" | "pdf" | "image" | "text"
  publishDate     DateTime? @map("publish_date")
  category        String? // "official" | "intergovernmental" | "watchdog" | "academic" | "media"
  isControversy   Boolean   @default(false) @map("is_controversy")
  isHistory       Boolean   @default(false) @map("is_history")
  relevanceScore  Float     @default(0.0) @map("relevance_score")
  qualityScore    Float     @default(0.0) @map("quality_score")
  importanceScore Float     @default(50.0) @map("importance_score")
  whyItMatters    String?   @map("why_it_matters")
  summary         String?
  facts           Json?
  quotes          Json?
  provenance      Json?
  hero            Json?
  metadata        Json?
  contentHash     String?   @map("content_hash")
  content         String?   @db.Text // Legacy field (required by database, nullable in schema)
  // New fields for robust crawler
  rawHtml         Bytes?    @map("raw_html")
  textContent     String?   @map("text_content") @db.Text
  keyFacts        Json?     @map("key_facts") // array of strings
  notableQuotes   Json?     @map("notable_quotes") // array of {quote:string, attribution?:string, sourceUrl?:string}
  isUseful        Boolean?  @map("is_useful") // relevance heuristic
  lastCrawledAt   DateTime? @map("last_crawled_at")
  createdAt       DateTime  @default(now()) @map("created_at")

  patch              Patch               @relation(fields: [patchId], references: [id], onDelete: Cascade)
  heroRecord         Hero?               @relation("HeroToContent") // One-to-one relation (renamed to avoid conflict with JSON hero field)
  wikipediaCitations WikipediaCitation[]

  @@unique([patchId, canonicalUrl])
  @@index([patchId])
  @@index([patchId, createdAt])
  @@index([contentHash])
  @@index([domain])
  @@index([sourceDomain])
  @@index([lastCrawledAt])
  @@map("discovered_content")
}

// Crawl Frontier for durable dedupe across runs
model CrawlFrontier {
  url           String    @id @db.Text
  source        String? // 'wikipedia', 'news', 'blog', etc.
  firstSeenAt   DateTime  @default(now()) @map("first_seen_at")
  lastTriedAt   DateTime? @map("last_tried_at")
  status        String    @default("pending") // pending|success|failed|skipped
  failReason    String?   @map("fail_reason") @db.Text
  depth         Int       @default(0)
  parentUrl     String?   @map("parent_url") @db.Text
  normalizedUrl String    @unique @map("normalized_url") @db.Text
  retryCount    Int       @default(0) @map("retry_count")
  robotsAllowed Boolean?  @map("robots_allowed")
  httpStatus    Int?      @map("http_status")
  contentType   String?   @map("content_type") @db.VarChar(255)
  title         String?   @db.Text
  sha256        String?   @db.VarChar(64) // body hash for change detection

  @@index([status, lastTriedAt])
  @@index([depth])
  @@index([normalizedUrl])
  @@map("crawl_frontier")
}

// Hero enrichment for DiscoveredContent
model Hero {
  id             String     @id @default(cuid())
  contentId      String     @unique @map("content_id") // FK to DiscoveredContent.id
  title          String     @db.Text
  excerpt        String?    @db.Text // Paraphrased summary (no quotes)
  quoteHtml      String?    @map("quote_html") @db.Text // ≤2 paragraphs, ≤1200 chars
  quoteCharCount Int?       @default(0) @map("quote_char_count")
  imageUrl       String?    @map("image_url") @db.Text // Nullable - hero can exist without image
  sourceUrl      String     @map("source_url") @db.Text // Canonical URL that was read
  status         HeroStatus @default(DRAFT)
  errorCode      String?    @map("error_code") @db.VarChar(50) // PAYWALL, TIMEOUT, etc.
  errorMessage   String?    @map("error_message") @db.Text
  traceId        String?    @map("trace_id") @db.VarChar(64) // For observability
  createdAt      DateTime   @default(now()) @map("created_at")
  updatedAt      DateTime   @updatedAt @map("updated_at")

  content DiscoveredContent @relation("HeroToContent", fields: [contentId], references: [id], onDelete: Cascade)

  @@index([contentId])
  @@index([status])
  @@index([traceId])
  @@index([createdAt])
  @@map("heroes")
}

enum HeroStatus {
  DRAFT // Being processed
  READY // Successfully enriched
  ERROR // Failed (but hero record exists for retry)
}

// Discovery seen tracking for durable duplicate prevention across runs
model DiscoverySeen {
  url       String   @id @db.Text
  firstSeen DateTime @default(now()) @map("first_seen")
  lastSeen  DateTime @default(now()) @updatedAt @map("last_seen")
  lastRunId String?  @map("last_run_id") @db.VarChar(64)
  timesSeen Int      @default(1) @map("times_seen")
  patchId   String?  @map("patch_id") @db.VarChar(64)
  domain    String?  @db.VarChar(255)

  @@index([patchId])
  @@index([domain])
  @@index([lastSeen])
  @@map("discovery_seen")
}

// Crawler raw page storage (Phase 1: Foundation)
model CrawlerPage {
  id              String    @id @default(cuid())
  url             String    @unique @db.Text
  domain          String    @db.Text
  status          String // "pending" | "fetched" | "failed" | "extracted"
  firstSeenAt     DateTime  @default(now()) @map("first_seen_at")
  lastProcessedAt DateTime? @map("last_processed_at")
  textHash        String?   @map("text_hash") @db.Text
  bytes           Int?      @default(0)
  httpStatus      Int?      @map("http_status")
  reasonCode      String?   @map("reason_code") @db.Text // "robots_blocked" | "timeout" | "dns_error" | "http_403" | "paywall" | "content_too_short"
  rawHtml         String?   @map("raw_html") @db.Text
  extractedText   String?   @map("extracted_text") @db.Text
  canonicalUrl    String?   @map("canonical_url") @db.Text

  extraction CrawlerExtraction?

  @@index([domain])
  @@index([status])
  @@index([textHash])
  @@index([firstSeenAt])
  @@index([lastProcessedAt])
  @@map("crawler_pages")
}

// LLM extraction results (Phase 4: LLM Extractor)
model CrawlerExtraction {
  id                 String   @id @default(cuid())
  pageId             String   @unique @map("page_id")
  topic              String   @db.Text
  sourceUrl          String   @map("source_url") @db.Text
  title              String   @db.Text
  top10Facts         Json     @map("top_10_facts") // string[]
  quotedPassages     Json     @map("quoted_passages") // Array<{quote: string, context_note: string}>
  paraphraseSummary  String   @map("paraphrase_summary") @db.Text
  controversialFlags Json?    @map("controversial_flags") // string[] | null
  metadata           Json // {domain: string, crawl_timestamp: string, char_count: number}
  createdAt          DateTime @default(now()) @map("created_at")

  page CrawlerPage @relation(fields: [pageId], references: [id], onDelete: Cascade)

  @@index([topic])
  @@index([sourceUrl])
  @@index([createdAt])
  @@map("crawler_extractions")
}

// Discovery Audit Trail Models
model DiscoveryRun {
  id        String    @id @default(cuid())
  patchId   String    @map("patch_id")
  startedAt DateTime  @default(now()) @map("started_at")
  endedAt   DateTime? @map("ended_at")
  status    String // live | completed | aborted | error
  metrics   Json? // {timeToFirst, novelRate, dupRate, itemsSaved, ...}

  patch  Patch            @relation(fields: [patchId], references: [id], onDelete: Cascade)
  audits DiscoveryAudit[]

  @@index([patchId, startedAt])
  @@map("discovery_runs")
}

model DiscoveryAudit {
  id           String   @id @default(cuid())
  runId        String   @map("run_id")
  patchId      String   @map("patch_id")
  step         String // searching|meta|fetch|relevance|quality|dedupe|synthesis|hero|save|error
  status       String // pending|ok|fail
  ts           DateTime @default(now())
  provider     String? // rss|wikipedia|official-site|web-search:bing|...
  query        String?  @db.Text
  candidateUrl String?  @map("candidate_url") @db.Text
  finalUrl     String?  @map("final_url") @db.Text
  http         Json? // {code, contentType, bytes}
  meta         Json? // {title,h1,preview,domain,publishedAt}
  rulesHit     Json?    @map("rules_hit") // {mustMention:true, primaryPage:false, negativeFilter:false}
  scores       Json? // {relevance:0.82, duplicateHitRate:0.12, simhashDistance:7}
  decisions    Json? // {reason:"relevance<0.75", action:"drop"} or {reason:"OK", action:"keep"}
  hashes       Json? // {contentHash, canonicalUrl}
  synthesis    Json? // {whyItMatters, facts[], quotes[], provenance[]}
  hero         Json? // {source:"ai|wikimedia|skeleton", url, attribution, durationMs}
  timings      Json? // {metaMs, fetchMs, vetMs, synthMs, heroMs, totalMs}
  error        Json?

  run   DiscoveryRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  patch Patch        @relation(fields: [patchId], references: [id], onDelete: Cascade)

  @@index([runId, ts])
  @@index([patchId])
  @@map("discovery_audits")
}

model SeenUrl {
  id            String   @id @default(cuid())
  patchId       String   @map("patch_id")
  urlHash       String   @map("url_hash") @db.VarChar(64) // SHA-256 hash of normalized URL
  urlNormalized String   @map("url_normalized") @db.Text
  firstSeenAt   DateTime @default(now()) @map("first_seen_at")
  lastSeenAt    DateTime @default(now()) @updatedAt @map("last_seen_at")
  timesSeen     Int      @default(1) @map("times_seen")

  patch Patch @relation(fields: [patchId], references: [id], onDelete: Cascade)

  @@unique([patchId, urlHash])
  @@index([patchId, lastSeenAt])
  @@map("seen_urls")
}

// Wikipedia Deep Link Extraction System
// Tracks Wikipedia pages being monitored for each patch
model WikipediaMonitoring {
  id                 String    @id @default(cuid())
  patchId            String    @map("patch_id")
  wikipediaUrl       String    @map("wikipedia_url") @db.Text
  wikipediaTitle     String    @map("wikipedia_title") @db.Text
  searchTerm         String?   @map("search_term") // Which search term found this page
  contentScanned     Boolean   @default(false) @map("content_scanned")
  contentText        String?   @map("content_text") @db.Text // Scanned content for memory
  lastScannedAt      DateTime? @map("last_scanned_at")
  citationCount      Int       @default(0) @map("citation_count")
  citationsExtracted Boolean   @default(false) @map("citations_extracted")
  lastExtractedAt    DateTime? @map("last_extracted_at")
  priority           Int       @default(0) // Higher = process first
  status             String    @default("pending") // pending | scanning | completed | error
  errorMessage       String?   @map("error_message") @db.Text
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")

  patch     Patch               @relation(fields: [patchId], references: [id], onDelete: Cascade)
  citations WikipediaCitation[]

  @@unique([patchId, wikipediaUrl])
  @@index([patchId, status, priority])
  @@index([patchId, citationsExtracted])
  @@index([patchId, lastScannedAt])
  @@map("wikipedia_monitoring")
}

// Citations extracted from Wikipedia pages
model WikipediaCitation {
  id                 String    @id @default(cuid())
  monitoringId       String    @map("monitoring_id")
  sourceNumber       Int       @map("source_number") // Reference number on Wikipedia page
  citationUrl        String    @map("citation_url") @db.Text
  citationTitle      String?   @map("citation_title") @db.Text
  citationContext    String?   @map("citation_context") @db.Text
  aiPriorityScore    Float?    @map("ai_priority_score") // AI-scored relevance (0-100)
  verificationStatus String    @default("pending") @map("verification_status") // pending | verified | failed
  scanStatus         String    @default("not_scanned") @map("scan_status") // not_scanned | scanning | scanned
  relevanceDecision  String?   @map("relevance_decision") // saved | denied | null
  savedContentId     String?   @map("saved_content_id") // FK to DiscoveredContent if saved
  savedMemoryId      String?   @unique @map("saved_memory_id") // FK to AgentMemory if saved as knowledge (unique for one-to-one)
  lastVerifiedAt     DateTime? @map("last_verified_at")
  lastScannedAt      DateTime? @map("last_scanned_at")
  errorMessage       String?   @map("error_message") @db.Text
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")

  monitoring   WikipediaMonitoring @relation(fields: [monitoringId], references: [id], onDelete: Cascade)
  savedContent DiscoveredContent?  @relation(fields: [savedContentId], references: [id], onDelete: SetNull)
  savedMemory  AgentMemory?        @relation(fields: [savedMemoryId], references: [id], onDelete: SetNull)

  @@unique([monitoringId, sourceNumber])
  @@index([monitoringId, verificationStatus, scanStatus])
  @@index([monitoringId, aiPriorityScore])
  @@index([verificationStatus, scanStatus])
  @@index([citationUrl])
  @@map("wikipedia_citations")
}
